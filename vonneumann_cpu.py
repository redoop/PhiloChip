#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
冯·诺依曼 CPU：现代计算机架构的直接实现
基于冯·诺依曼架构（1945）
这是所有现代计算机的工程基础
"""

class VonNeumannCPU:
    """
    冯·诺依曼 CPU：存储程序计算机
    
    冯·诺依曼架构的核心：
    1. 存储程序（Stored Program）
    2. 数据与指令统一存储
    3. 顺序执行
    4. 五大组件：运算器、控制器、存储器、输入、输出
    """
    
    def __init__(self):
        # 8 大架构组件（3-bit 高位）
        self.components = {
            0b000: "运算器",      # ALU - Arithmetic Logic Unit
            0b001: "控制器",      # Control Unit
            0b010: "存储器",      # Memory
            0b011: "输入设备",    # Input
            0b100: "输出设备",    # Output
            0b101: "总线",        # Bus
            0b110: "程序计数器",  # Program Counter
            0b111: "指令周期",    # Instruction Cycle
        }
        
        self.instructions = self._build_instructions()
    
    def _build_instructions(self):
        """构建 128 条指令"""
        inst = {}
        
        mappings = [
            # 运算器（0x00-0x0F）：ALU 操作
            (0x00, "ADD", "加", "加法运算"),
            (0x01, "SUB", "减", "减法运算"),
            (0x02, "MUL", "乘", "乘法运算"),
            (0x03, "DIV", "除", "除法运算"),
            (0x04, "MOD", "模", "取模运算"),
            (0x05, "AND", "与", "逻辑与"),
            (0x06, "OR", "或", "逻辑或"),
            (0x07, "XOR", "异或", "逻辑异或"),
            (0x08, "NOT", "非", "逻辑非"),
            (0x09, "SHL", "左移", "逻辑左移"),
            (0x0A, "SHR", "右移", "逻辑右移"),
            (0x0B, "INC", "增", "自增"),
            (0x0C, "DEC", "减", "自减"),
            (0x0D, "NEG", "负", "取负"),
            (0x0E, "CMP", "比较", "比较运算"),
            (0x0F, "TEST", "测试", "测试位"),
            
            # 控制器（0x10-0x1F）：控制流
            (0x10, "JMP", "跳转", "无条件跳转"),
            (0x11, "JZ", "零跳", "零跳转"),
            (0x12, "JNZ", "非零跳", "非零跳转"),
            (0x13, "JE", "等跳", "相等跳转"),
            (0x14, "JNE", "不等跳", "不等跳转"),
            (0x15, "JL", "小跳", "小于跳转"),
            (0x16, "JG", "大跳", "大于跳转"),
            (0x17, "JLE", "小等跳", "小于等于跳转"),
            (0x18, "JGE", "大等跳", "大于等于跳转"),
            (0x19, "CALL", "调用", "子程序调用"),
            (0x1A, "RET", "返回", "子程序返回"),
            (0x1B, "LOOP", "循环", "循环控制"),
            (0x1C, "INT", "中断", "中断调用"),
            (0x1D, "IRET", "中断返回", "中断返回"),
            (0x1E, "NOP", "空操作", "无操作"),
            (0x1F, "HALT", "停机", "停机"),
            
            # 存储器（0x20-0x2F）：内存操作（核心！）
            (0x20, "LOAD", "加载", "从内存加载"),
            (0x21, "STORE", "存储", "存入内存"),
            (0x22, "MOV", "移动", "数据移动"),
            (0x23, "PUSH", "压栈", "压入栈"),
            (0x24, "POP", "出栈", "弹出栈"),
            (0x25, "LEA", "取地址", "加载有效地址"),
            (0x26, "XCHG", "交换", "交换数据"),
            (0x27, "LOADB", "加载字节", "加载字节"),
            (0x28, "STOREB", "存字节", "存储字节"),
            (0x29, "LOADW", "加载字", "加载字"),
            (0x2A, "STOREW", "存字", "存储字"),
            (0x2B, "FETCH", "取指", "取指令（关键！）"),
            (0x2C, "DECODE", "译码", "指令译码"),
            (0x2D, "EXECUTE", "执行", "执行指令"),
            (0x2E, "WRITEBACK", "写回", "结果写回"),
            (0x2F, "CACHE", "缓存", "缓存操作"),
            
            # 输入设备（0x30-0x3F）：输入操作
            (0x30, "IN", "输入", "端口输入"),
            (0x31, "INB", "输入字节", "字节输入"),
            (0x32, "INW", "输入字", "字输入"),
            (0x33, "READ", "读取", "读取数据"),
            (0x34, "SCAN", "扫描", "扫描输入"),
            (0x35, "GETC", "取字符", "获取字符"),
            (0x36, "GETS", "取字符串", "获取字符串"),
            (0x37, "RECV", "接收", "接收数据"),
            (0x38, "POLL", "轮询", "轮询输入"),
            (0x39, "WAIT", "等待", "等待输入"),
            (0x3A, "SENSE", "感知", "感知设备"),
            (0x3B, "SAMPLE", "采样", "采样数据"),
            (0x3C, "CAPTURE", "捕获", "捕获数据"),
            (0x3D, "ACQUIRE", "获取", "获取资源"),
            (0x3E, "ACCEPT", "接受", "接受连接"),
            (0x3F, "LISTEN", "监听", "监听端口"),
            
            # 输出设备（0x40-0x4F）：输出操作
            (0x40, "OUT", "输出", "端口输出"),
            (0x41, "OUTB", "输出字节", "字节输出"),
            (0x42, "OUTW", "输出字", "字输出"),
            (0x43, "WRITE", "写入", "写入数据"),
            (0x44, "PRINT", "打印", "打印输出"),
            (0x45, "PUTC", "放字符", "输出字符"),
            (0x46, "PUTS", "放字符串", "输出字符串"),
            (0x47, "SEND", "发送", "发送数据"),
            (0x48, "FLUSH", "刷新", "刷新缓冲"),
            (0x49, "DISPLAY", "显示", "显示数据"),
            (0x4A, "RENDER", "渲染", "渲染图形"),
            (0x4B, "DRAW", "绘制", "绘制"),
            (0x4C, "EMIT", "发射", "发射信号"),
            (0x4D, "TRANSMIT", "传输", "传输数据"),
            (0x4E, "BROADCAST", "广播", "广播消息"),
            (0x4F, "SIGNAL", "信号", "发送信号"),
            
            # 总线（0x50-0x5F）：数据传输
            (0x50, "BUS", "总线", "总线操作"),
            (0x51, "TRANSFER", "传输", "数据传输"),
            (0x52, "DMA", "直接存储", "DMA 传输"),
            (0x53, "BURST", "突发", "突发传输"),
            (0x54, "STREAM", "流", "流传输"),
            (0x55, "PIPELINE", "流水线", "流水线传输"),
            (0x56, "PREFETCH", "预取", "预取数据"),
            (0x57, "BUFFER", "缓冲", "缓冲数据"),
            (0x58, "QUEUE", "队列", "队列操作"),
            (0x59, "FIFO", "先进先出", "FIFO 队列"),
            (0x5A, "LIFO", "后进先出", "LIFO 栈"),
            (0x5B, "ARBITER", "仲裁", "总线仲裁"),
            (0x5C, "GRANT", "授权", "总线授权"),
            (0x5D, "REQUEST", "请求", "总线请求"),
            (0x5E, "ACKNOWLEDGE", "应答", "总线应答"),
            (0x5F, "HANDSHAKE", "握手", "握手协议"),
            
            # 程序计数器（0x60-0x6F）：PC 操作（核心！）
            (0x60, "PC", "程序计数器", "PC 寄存器"),
            (0x61, "NEXT", "下一条", "PC++（顺序执行）"),
            (0x62, "GOTO", "转到", "PC = addr"),
            (0x63, "BRANCH", "分支", "条件修改 PC"),
            (0x64, "SKIP", "跳过", "跳过指令"),
            (0x65, "REPEAT", "重复", "重复执行"),
            (0x66, "CONTINUE", "继续", "继续执行"),
            (0x67, "BREAK", "中断", "中断执行"),
            (0x68, "RESUME", "恢复", "恢复执行"),
            (0x69, "SUSPEND", "挂起", "挂起执行"),
            (0x6A, "STEP", "单步", "单步执行"),
            (0x6B, "TRACE", "跟踪", "跟踪执行"),
            (0x6C, "DEBUG", "调试", "调试模式"),
            (0x6D, "BREAKPOINT", "断点", "设置断点"),
            (0x6E, "WATCHPOINT", "观察点", "设置观察点"),
            (0x6F, "PROFILE", "性能分析", "性能分析"),
            
            # 指令周期（0x70-0x7F）：取指-译码-执行（核心！）
            (0x70, "FETCH_CYCLE", "取指周期", "取指令周期"),
            (0x71, "DECODE_CYCLE", "译码周期", "译码周期"),
            (0x72, "EXECUTE_CYCLE", "执行周期", "执行周期"),
            (0x73, "MEMORY_CYCLE", "访存周期", "访存周期"),
            (0x74, "WRITEBACK_CYCLE", "写回周期", "写回周期"),
            (0x75, "INTERRUPT_CYCLE", "中断周期", "中断周期"),
            (0x76, "EXCEPTION", "异常", "异常处理"),
            (0x77, "TRAP", "陷阱", "陷阱处理"),
            (0x78, "FAULT", "故障", "故障处理"),
            (0x79, "ABORT_CYCLE", "中止", "中止执行"),
            (0x7A, "RESET", "复位", "系统复位"),
            (0x7B, "BOOT", "启动", "系统启动"),
            (0x7C, "SHUTDOWN", "关机", "系统关机"),
            (0x7D, "SLEEP", "休眠", "进入休眠"),
            (0x7E, "WAKE", "唤醒", "唤醒系统"),
            (0x7F, "VONNEUMANN", "冯·诺依曼", "架构完成"),
        ]
        
        for opcode, mnemonic, name, desc in mappings:
            component = (opcode >> 4) & 0b111
            inst[opcode] = {
                "opcode": opcode,
                "hex": f"0x{opcode:02X}",
                "binary": f"{opcode:07b}",
                "mnemonic": mnemonic,
                "name": name,
                "component": self.components[component],
                "description": desc
            }
        
        return inst
    
    def print_instruction_set(self):
        """打印指令集"""
        print("=" * 100)
        print("冯·诺依曼 CPU 指令集（128 条）")
        print("基于冯·诺依曼架构（1945）- 现代计算机的工程基础")
        print("=" * 100)
        
        categories = [
            ("运算器：ALU", 0x00, 0x10),
            ("控制器：控制流", 0x10, 0x20),
            ("存储器：内存操作（核心）", 0x20, 0x30),
            ("输入设备：输入", 0x30, 0x40),
            ("输出设备：输出", 0x40, 0x50),
            ("总线：数据传输", 0x50, 0x60),
            ("程序计数器：PC（核心）", 0x60, 0x70),
            ("指令周期：取指-译码-执行（核心）", 0x70, 0x80),
        ]
        
        for cat_name, start, end in categories:
            print(f"\n【{cat_name}】")
            for opcode in range(start, end):
                if opcode in self.instructions:
                    inst = self.instructions[opcode]
                    print(f"  {inst['hex']} | {inst['mnemonic']:18s} | {inst['name']:8s} | {inst['description']}")
        
        print(f"\n总计: {len(self.instructions)} 条指令")
        print("=" * 100)
    
    def show_architecture(self):
        """展示冯·诺依曼架构"""
        print("\n" + "=" * 100)
        print("冯·诺依曼架构")
        print("=" * 100)
        
        print("""
【五大组件】

1. 运算器（ALU - Arithmetic Logic Unit）
   - 执行算术运算（加减乘除）
   - 执行逻辑运算（与或非）
   - 现代 CPU 的核心

2. 控制器（Control Unit）
   - 控制程序执行流程
   - 管理指令周期
   - 协调各部件工作

3. 存储器（Memory）
   - 存储程序（指令）
   - 存储数据
   - 统一编址（关键创新！）

4. 输入设备（Input）
   - 键盘、鼠标、网络等
   - 将外部数据输入计算机

5. 输出设备（Output）
   - 显示器、打印机、网络等
   - 将计算结果输出

【核心创新：存储程序】

传统计算机（ENIAC）：
- 程序通过硬件连线实现
- 改变程序需要重新布线
- 非常不灵活

冯·诺依曼架构：
- 程序存储在内存中
- 程序和数据统一编址
- 可以像修改数据一样修改程序
- 这是现代计算机的基础！

【指令执行周期】

1. 取指（Fetch）
   - PC → 地址总线 → 内存
   - 内存 → 数据总线 → IR（指令寄存器）
   - PC++

2. 译码（Decode）
   - 控制器解析指令
   - 确定操作类型和操作数

3. 执行（Execute）
   - ALU 执行运算
   - 或访问内存
   - 或执行 I/O

4. 写回（Writeback）
   - 结果写回寄存器或内存

【冯·诺依曼瓶颈】

问题：CPU 和内存之间的数据传输速度限制
- CPU 速度：GHz 级别
- 内存速度：MHz 级别
- 总线带宽有限

解决方案：
- 缓存（Cache）
- 流水线（Pipeline）
- 并行处理
- 哈佛架构（指令和数据分离）

【与图灵机的关系】

图灵机（1936）：
- 理论模型
- 证明可计算性
- 无限纸带

冯·诺依曼架构（1945）：
- 工程实现
- 有限内存
- 实际可制造

图灵 = 理论
冯·诺依曼 = 工程
        """)
        print("=" * 100)


def main():
    cpu = VonNeumannCPU()
    
    cpu.print_instruction_set()
    cpu.show_architecture()
    
    print("\n" + "=" * 100)
    print("总结")
    print("=" * 100)
    print("""
【冯·诺依曼 CPU 特点】
✅ 存储程序（核心创新）
✅ 数据与指令统一存储
✅ 顺序执行
✅ 五大组件清晰
✅ 所有现代计算机的基础

【历史地位】
约翰·冯·诺依曼（1903-1957）
    ↓
EDVAC 报告（1945）
    ↓
存储程序概念
    ↓
冯·诺依曼架构
    ↓
EDVAC, EDSAC, IAS 机器
    ↓
所有现代计算机

【冯·诺依曼的贡献】
✅ 存储程序概念（革命性）
✅ 数据与指令统一编址
✅ 二进制计算机
✅ 指令执行周期
✅ 五大组件架构
✅ 可编程计算机的工程实现

【与其他思想家对比】
- 莱布尼兹（1679）：发明二进制
- 布尔（1854）：发明逻辑代数
- 图灵（1936）：发明计算理论
- 冯·诺依曼（1945）：工程实现

理论 → 工程：
- 图灵机 → 冯·诺依曼架构
- 抽象模型 → 实际计算机
- 无限纸带 → 有限内存

【实际应用】
1. 所有现代计算机（x86, ARM, RISC-V）
2. 所有微处理器
3. 所有嵌入式系统
4. 手机、电脑、服务器
5. 游戏机、智能设备
6. 几乎所有数字计算设备

【实用性评估】
- 工程重要性：10/10（最高）
- 实际应用：10/10（所有计算机）
- 历史地位：10/10（现代计算机之父）
- 影响范围：10/10（全球）
- 教育价值：10/10（必学架构）
- 商业价值：10/10（万亿美元产业）

【结论】
冯·诺依曼架构 = 现代计算机的工程基础
所有计算机都是冯·诺依曼架构的变体

从理论到实践的关键一步：
- 图灵：定义了"什么是计算"
- 冯·诺依曼：实现了"如何计算"

没有冯·诺依曼，就没有现代计算机产业！

"如果人们不相信数学是简单的，
那只是因为他们没有意识到生活有多复杂。"
- 约翰·冯·诺依曼
    """)
    print("=" * 100)


if __name__ == "__main__":
    main()
